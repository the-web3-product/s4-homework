# 比特币脚本（Bitcoin Script）通俗解释
它是用来描述“这笔钱在什么条件下才能被花掉”。不是智能合约平台（不图灵完备、无循环），而是一个安全保守、可验证的小脚本系统。

输出（UTXO）里有“锁定脚本”（scriptPubKey）= 上锁规则。

花费时，输入提供“解锁脚本”（scriptSig/见证数据）= 开锁凭证。

节点把“解锁+锁定”拼起来执行；栈顶为真（True）才算有效。

怎么运行：基于栈（Stack-based）。

脚本把数据和指令依次压栈、弹栈操作。

没有循环与全局状态，执行结束时若栈顶为真则通过。


# Schnorr 签名
它是一种在椭圆曲线上工作的数字签名方案。特点是“公式简单、结构线性”，因此更易证明安全、也更易做合并签名。比特币 Taproot（BIP340）就用的它。


# Taproot升级
它是比特币在 2021-11-14（区块 709632）启用的一次协议升级，核心目的是让交易更省费、更隐私、更灵活。包含三部分：

BIP340：Schnorr 签名

BIP341：Taproot（新输出类型 P2TR）

BIP342：Tapscript（新版脚本规则）


像把“复杂合约”藏在一棵树里：真正用到哪一条规则，只在花费时才露出那一条（MAST）。没用到的分支不公开，隐私更好、数据更少。
能“把多人签名合成一枚印章”：Schnorr 的线性特性让多签聚合更自然（如 MuSig2），链上看起来像一次普通签名。


两种花费方式：

Key-path：用一枚 Schnorr 签名花费（最省、最隐私，像普通单签）。

Script-path：公开脚本的某个分支 + 证明，按那条规则花费。


# MAST 是什么（Merkleized Abstract Syntax Tree）

把“同一枚 UTXO 的多种花费条件”做成一棵 Merkle 树，链上只承诺这棵树的根；真正花钱时，只公开你用到的那一条分支和它的证明。


为什么要这样做

更隐私：没用到的条件不暴露（别人看不到还有哪些备选规则）。

更省费：区块里只放“用到的脚本分支+证明”，体积≈用到那条的大小，而不是所有条件的总和。

更灵活：可以把复杂策略拆成多条“独立分支”（如多签、时间锁、应急路径等）。

Taproot 的 script-path 花费就用 MAST；配合 key-path（单签更省）一起提供“常用走单签，特殊走脚本”的组合。

### “铭文”（Ordinals Inscriptions）
是在比特币上“给某个聪写字/贴文件”。它把一段数据（图片、文本、JSON 等）写进链上见证数据，并把这段数据和某个聪绑定，之后转这枚聪就等于转这份“作品”。

两块拼起来
Ordinals（序号规则）：给每个聪编号，允许把数据“挂”到某个聪上。
Inscription（写入数据）：把实际内容放进 Taproot 见证区，链上永久存证。

### 原理：
利用 Taproot/Tapscript 的见证数据空间，把内容（含类型，如 image/png 或 text/plain）嵌进去；
节点只当普通交易验证，不理解内容；索引器根据约定识别、展示。

### 特点
上链存储：内容直接在链上，抗审查、可长期验证。
随聪转移：铭文和那枚聪绑定，转账即转“作品”。
费用与拥堵：内容越大，手续费越高，会占用区块空间。

### 和BRC-20 的关系
BRC-20 是“用铭文里的文本/JSON约定”来模拟可替代代币的玩法；不是比特币协议原生代币，余额全靠索引器规则达成“社群共识”。

不是“官方发币”：矿工/节点不追踪 BRC-20 余额，只打包交易。
UTXO 膨胀与费用上行是实际成本，需要全网共同承担。

铭文就是“把一段数据刻在某枚聪上”的玩法：真上链、能转移，但占空间、费不低，BRC-20 等只是基于它的社区约定。

# BRC 20
通过BRC20协议发行代币可以以1聪发行一个代币或是多个代币、NFT、域名。把一段 JSON 文本刻到比特币链上，靠索引器读这些文本来“记账”，从而模拟可替代代币。不是比特币原生标准，也没有链上合约逻辑。

Ordinals 铭文里写规则与操作，常见三种：deploy（发布）、mint（铸造）、transfer（转账）。
钱包/网站的索引器扫描交易见证数据，按约定解析并计算余额；矿工/节点并不理解“BRC-20 余额”。

deploy 定义代币；之后用 mint 铸造，transfer 转出。是否有效、谁有多少，全靠索引器按规则认定。

依赖索引器一致性；容易造成链上拥堵与手续费上行；UTXO 膨胀；规则易分叉；资产风险高。

BRC-20 是“把代币规则写成铭文文本、由索引器记账”的社区协议，看起来像代币，实际没有链上合约与原生余额，风险与争议都不小。


# “符文”（Runes）
它是在比特币上发行/转账“可替代代币”的一种新协议（由 Ordinals 作者 Casey 提出，2024 年上线）。不依赖铭文文本，走更“原生 UTXO”的记账方式。

### 流程

Etch（刻写）：创建新代币，定义名称、精度、小数位、供应/铸造规则等。

Mint（铸造）：按规则增发。

Edict（法令）/Transfer：把某 UTXO 上的代币余额转到新 UTXO（用 OP_RETURN 携带“Runestone”消息，索引器解析）。

余额与具体 UTXO 绑定；花费旧 UTXO、在新 UTXO 上“重建”余额，更贴合比特币的 UTXO 模型。

### 和 BRC-20 的区别

BRC-20：把 JSON 刻进铭文，索引器“解释”成余额，容易产生大体积数据与 UTXO 膨胀。

Runes：用精简的 OP_RETURN 消息和 UTXO 绑定的余额模型，体积更小、结构更清晰、批量转账更自然。

### 优点

更省区块空间、对 UTXO 友好；解析规则简单明确；一次交易可高效分发多资产。

### 限制/风险

依然是“共识外协议”（需索引器）；资产价值与规则一致性取决于生态实现与共识；同样存在投机与拥堵风险。

### 怎么用

通过支持 Runes 的钱包/交易平台：创建（Etch）、按规则铸造（Mint）、转账（Edict/Transfer）；手续费随交易与 OP_RETURN 大小而定。

符文是更贴近比特币 UTXO 的代币协议，用小而精的链上消息记录代币状态，目标是比 BRC‑20 更省空间、更“原生”、更可维护。

## 铭文、符文与原生比特币的关系

原生比特币（BTC）：链上唯一“共识内”资产；余额、有效性由全网节点/矿工按共识规则直接维护。

铭文（Inscriptions）：把内容数据写进交易见证并与某枚聪绑定；“含义”由索引器解释，不在比特币共识里，不产生原生新资产。

BRC‑20：基于铭文的文本约定来模拟代币；余额全靠索引器计算，不在共识内。

符文（Runes）：用精简的 OP_RETURN 消息（“Runestone”）+ UTXO 绑定做代币记账；语义同样由索引器解释，不在共识内。

简言之：BTC 是共识内资产；铭文/BRC‑20/符文都是“把数据放上链、由工具赋义”的共识外协议。

## 交易上的共性与区别

### 共性（都需要矿工+节点）

都是标准的比特币交易，进入同一个内存池，竞争同一块空间。

都必须被矿工打包、被节点按比特币规则验证（签名、脚本、大小/权重等）。

确认与终局性和 BTC 一样（N 次确认越稳）。

### 关键区别（谁来验证“代币语义”）

节点/矿工只验证“比特币交易是否有效”。

不会检查“这段数据代表哪个代币、余额是否足够”等语义。

铭文/BRC‑20/符文的“发行、转账、余额”由索引器/钱包按各自协议规则计算；不同实现可能产生分歧。

数据放哪儿、成本与模型

铭文：数据在 Taproot 见证里，体积可大，费用高；所有权=那枚带铭文的聪所在 UTXO 的所有权。

BRC‑20：在铭文里刻 JSON 操作（deploy/mint/transfer），解析重、易膨胀。

符文：指令在 OP_RETURN，体量小、结构贴合 UTXO；余额与具体 UTXO 绑定，批量分发更自然。

三者的“转账成功与否”在链上只是“交易被确认”；具体“代币余额是否变化”取决于索引器如何解读那笔交易的数据。

要点总结：

BTC 是共识内；铭文/BRC‑20/符文是共识外的“解释层”。

交易都要矿工打包、节点验证，但只有 BTC 余额由共识保障；代币语义由索引器解释，费用与确认与 BTC 相同，数据位置与记账模型不同。
