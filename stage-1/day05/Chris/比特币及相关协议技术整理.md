# 比特币及相关协议技术整理

## 一、比特币核心脚本与升级

### （一）基础脚本：锁定与解锁



1. **锁定脚本**：作用是在交易输出中锁定 BTC，定义解锁条件。

* 示例：`OP_DUP OP_HASH160 <收款人公钥哈希> OP_EQUALVERIFY OP_CHECKSIG`

* 核心规则：需提供 “签名 + 公钥”，且公钥哈希需与脚本中记录的一致，才能解锁 BTC。

1. **解锁脚本**：作用是在交易输入中提供解锁证明，满足锁定脚本条件。

* 示例：`<签名> <公钥>`

* 核心逻辑：提供对应签名和公钥，证明对该笔 BTC 的所有权。

### （二）关键技术升级



| 升级时间        | 名称              | 核心变化                                                                                                                      |
| ----------- | --------------- | ------------------------------------------------------------------------------------------------------------------------- |
| 2017 年      | SegWit（隔离见证）    | 将解锁脚本中的 “签名” 分离，放到新数据结构 “见证字段”，优化区块空间利用                                                                                   |
| 2021 年      | Taproot         | 进一步降低见证字段成本，提升功能扩展性，为后续铭文等应用奠定基础                                                                                          |
| 2023 年      | 铭文（Inscription） | 基于 Taproot 和 Ordinals 协议，将数据写入见证字段（以`false`标记不执行代码），546 聪 UTXO 即可生成 1 个铭文，代表应用为 BRC-20（依赖铭文记录部署、铸造、转移全生命周期，需中心化索引器计算余额状态） |
| 2023-2024 年 | 符文（Runes）       | 融入传统 BTC-UTXO 交易模型，随 BTC 转移，不产生极小 UTXO 垃圾，基于 Runes 协议                                                                     |

## 二、铭文上链技术流程（解锁时上链）

### 第 1 步：创建承诺（生成 “空保险箱”）



* 钱包构建铭文数据，通过哈希运算生成对应 Taproot 地址，该地址的数学结构 “承诺” 了铭文数据的存在。

* 此时仅地址（如`bc1p...`）的 “指纹”（哈希值）上链，铭文数据本身未上链。

### 第 2 步：花费并揭示（声明所有权）



* 需构造交易花费上述 Taproot 输出，在交易的 “见证字段” 中提供两样东西以满足解锁条件：

1. 有效的数字签名；

2. 完整铭文脚本（格式：`OP_FALSE OP_IF ... [图片/文本数据] ... OP_ENDIF`）。

### 第 3 步：永久记录（区块链公证）



* 矿工打包该交易，由于见证字段是比特币区块链合法组成部分，铭文脚本（含完整数据）被永久写入链上。

* Ordinals 协议索引器扫描区块链，发现符合格式的 Taproot 输出花费交易后，将铭文数据关联到对应聪上，完成铭刻。

## 三、铭文为何不放在锁定脚本里？（与传统 NFT 存储逻辑对比）



1. **成本问题**：SegWit 升级前，所有脚本数据占用昂贵区块空间，直接将大数据放入锁定脚本成本极高；

2. **Taproot 优势**：Taproot 升级后，见证字段数据享有大幅费用折扣，铭文利用这一点降低存储成本；

3. **灵活性**：“承诺 - 揭示” 模型可在承诺阶段（创建地址）隐藏数据内容，仅在最终花费时揭示，保护隐私。

* 总结：铭文数据并非作为 “被锁定资产” 存于输出（锁定脚本），而是作为 “解锁钥匙” 的一部分，在花费交易的见证字段中揭示并记录，是更经济、灵活的设计。

## 四、其他重要协议

### （一）ETH-Casper FFG（以太坊共识机制相关）



* 核心逻辑：每个 epoch 从第一个 slot 开始投票，不同 slot 由不同委员会负责；

* 最终确定规则：当当前 epoch 检查点被投票为 “安全” 时，若上一个 epoch 检查点已证明安全，则上一个 epoch 检查点变为 “最终确定” 状态（不可篡改）。

### （二）PSBT（Partially Signed Bitcoin Transaction，部分签名的比特币交易）



* 类比：“需多人会签生效的公文” 或 “多方填写的联名支票”，适用于硬件钱包离线签名场景。

* 流程：

1. **创建**：在线软件钱包（如 Sparrow Wallet）构建交易，输出含交易信息（输入、输出、金额等）但签名字段为空的 PSBT 文件；

2. **传递**：通过 MicroSD 卡 / 二维码将 PSBT 传给离线硬件钱包（如 Coldcard）；

3. **审查与部分签名**：硬件钱包显示交易详情，用户确认后用私钥部分签名，传回在线设备；

4. **组合与广播**：在线钱包组合 PSBT，生成完整签名交易，广播到比特币网络完成交易。

### （三）RGB（比特币生态资产协议）



* 核心特点：资产状态不直接写在比特币链上，依赖 UTXO 和离线数据验证。

* 流程：

1. **历史溯源**：资产源于早期 “单子”，该单子密封在比特币 UTXO（如 A1）中；

2. **创建新状态**：Alice 生成新转移单子（指明 “消费单子 T1，生成单子 T2 给 Bob 公钥”），并附上签名、历史数据等证明；

3. **比特币结算**：Alice 构建比特币交易，花费 UTXO A1、创建 UTXO B1，将新单子 T2 的哈希（承诺）写入 OP\_RETURN 或 Taproot 脚本，广播交易；

4. **数据交付**：Alice 通过离线方式（文件、邮件）将单子 T2 及完整历史链传给 Bob；

5. **客户端验证**：Bob 的 RGB 钱包检查 T2 承诺是否在链上、回溯历史链验证签名 / 状态转换 / UTXO 花费是否有效，验证通过则确认资产归属。

### （四）RGB++



* 核心改进：相比 RGB 增加 “去中心化索引器”，其他原理与铭文一致，优化数据验证的去中心化程度。